<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Futuristic Chess Neon Background</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
  }

  canvas {
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 30);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  // Chessboard grid parameters
  const rows = 16;
  const cols = 16;
  const squareSize = 1.5;
  const squares = [];
  const colors = [0x00ffff, 0xff00ff]; // Neon alternating colors

  for(let i=0; i<rows; i++){
    for(let j=0; j<cols; j++){
      const color = colors[(i+j)%2];
      const material = new THREE.MeshBasicMaterial({
        color: color,
        side: THREE.DoubleSide,
        transparent:true,
        opacity:0.7
      });
      const square = new THREE.Mesh(new THREE.PlaneGeometry(squareSize, squareSize), material);
      square.position.x = (i - rows/2) * squareSize;
      square.position.z = (j - cols/2) * squareSize;
      square.position.y = Math.random()*0.5; // slight floating
      square.rotation.x = -Math.PI/2;
      scene.add(square);
      squares.push(square);
    }
  }

  // Floating particles in front
  const particleCount = 300;
  const particleGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount*3);

  for(let i=0;i<particleCount;i++){
    positions[i*3] = (Math.random()-0.5)*30;
    positions[i*3+1] = Math.random()*10;
    positions[i*3+2] = (Math.random()-0.5)*30;
  }

  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));

  const particleMaterial = new THREE.PointsMaterial({
    color:0xffff00,
    size:0.5,
    transparent:true,
    opacity:1,
    depthWrite:false
  });

  const particles = new THREE.Points(particleGeometry, particleMaterial);
  particles.renderOrder = 999;
  scene.add(particles);

  // Mouse/touch interaction
  let mouse = {x:0, y:0};
  function updateMouse(x,y){ mouse.x = (x/window.innerWidth - 0.5)*2; mouse.y = (y/window.innerHeight - 0.5)*2; }

  window.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
  window.addEventListener('touchmove', e => { if(e.touches.length>0) updateMouse(e.touches[0].clientX,e.touches[0].clientY); });

  // Animate
  function animate(){
    requestAnimationFrame(animate);
    const time = Date.now()*0.002;

    // Floating wave effect for chessboard
    squares.forEach((sq, i)=>{
      sq.position.y = Math.sin(time + i*0.3)*0.3;
      sq.rotation.z = mouse.x*0.3;
      sq.rotation.x = -Math.PI/2 + mouse.y*0.3;
    });

    // Animate particles
    const pos = particles.geometry.attributes.position.array;
    for(let i=0;i<particleCount;i++){
      pos[i*3+1] += 0.05;
      if(pos[i*3+1]>10) pos[i*3+1] = 0;
    }
    particles.geometry.attributes.position.needsUpdate = true;
    particles.rotation.y += 0.002;

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>